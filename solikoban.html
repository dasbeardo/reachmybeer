import React, { useState, useEffect, useCallback } from ‘react’;

const TILE_SIZE = 40;
const EMPTY = 0;
const WALL = 1;
const BOX = 2;
const TARGET = 3;
const PLAYER = 4;
const BOX_ON_TARGET = 5;

// Puzzle generation parameters that scale with difficulty
const getDifficultyParams = (level) => {
const baseSize = Math.min(6 + Math.floor(level / 3), 12);
const maxBoxes = Math.min(2 + Math.floor(level / 2), 8);
const complexity = Math.min(level * 0.3, 5);

return {
width: baseSize + Math.floor(Math.random() * 3),
height: baseSize + Math.floor(Math.random() * 3),
numBoxes: Math.max(2, Math.min(maxBoxes, 2 + Math.floor(Math.random() * (2 + Math.floor(level / 2))))),
complexity: complexity,
deadEndProbability: Math.min(0.1 + (level * 0.02), 0.4),
narrowPassageProbability: Math.min(0.2 + (level * 0.03), 0.6)
};
};

// Breadth-first search to verify puzzle solvability
const solvePuzzle = (initialMap, playerStart) => {
const stringify = (map, playerPos) => {
return JSON.stringify({ map, player: playerPos });
};

const parseState = (stateStr) => {
return JSON.parse(stateStr);
};

const isWinState = (map) => {
for (let y = 0; y < map.length; y++) {
for (let x = 0; x < map[y].length; x++) {
if (map[y][x] === TARGET) return false;
}
}
return true;
};

const getBoxPositions = (map) => {
const boxes = [];
for (let y = 0; y < map.length; y++) {
for (let x = 0; x < map[y].length; x++) {
if (map[y][x] === BOX || map[y][x] === BOX_ON_TARGET) {
boxes.push({ x, y });
}
}
}
return boxes;
};

const isDeadlock = (map) => {
const boxes = getBoxPositions(map);

```
for (const box of boxes) {
  // Check if box is in a corner and not on target
  if (map[box.y][box.x] === BOX) {
    const corners = [
      { dx: -1, dy: -1 }, { dx: 1, dy: -1 },
      { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
    ];
    
    for (const corner of corners) {
      const x1 = box.x + corner.dx;
      const y1 = box.y + corner.dy;
      const x2 = box.x + corner.dx;
      const y2 = box.y;
      const x3 = box.x;
      const y3 = box.y + corner.dy;
      
      if (x1 >= 0 && x1 < map[0].length && y1 >= 0 && y1 < map.length &&
          x2 >= 0 && x2 < map[0].length && y2 >= 0 && y2 < map.length &&
          x3 >= 0 && x3 < map[0].length && y3 >= 0 && y3 < map.length) {
        
        if ((map[y2][x2] === WALL || map[y2][x2] === BOX || map[y2][x2] === BOX_ON_TARGET) &&
            (map[y3][x3] === WALL || map[y3][x3] === BOX || map[y3][x3] === BOX_ON_TARGET)) {
          return true; // Deadlock detected
        }
      }
    }
  }
}
return false;
```

};

const getNextStates = (map, playerPos) => {
const states = [];
const directions = [
{ dx: 0, dy: -1 }, { dx: 1, dy: 0 },
{ dx: 0, dy: 1 }, { dx: -1, dy: 0 }
];

```
for (const dir of directions) {
  const newX = playerPos.x + dir.dx;
  const newY = playerPos.y + dir.dy;
  
  if (newY < 0 || newY >= map.length || newX < 0 || newX >= map[0].length) continue;
  
  const targetTile = map[newY][newX];
  
  if (targetTile === WALL) continue;
  
  let newMap = map.map(row => [...row]);
  let canMove = true;
  
  if (targetTile === BOX || targetTile === BOX_ON_TARGET) {
    const boxNewX = newX + dir.dx;
    const boxNewY = newY + dir.dy;
    
    if (boxNewY < 0 || boxNewY >= newMap.length || 
        boxNewX < 0 || boxNewX >= newMap[0].length ||
        newMap[boxNewY][boxNewX] === WALL ||
        newMap[boxNewY][boxNewX] === BOX ||
        newMap[boxNewY][boxNewX] === BOX_ON_TARGET) {
      canMove = false;
    } else {
      const wasBoxOnTarget = targetTile === BOX_ON_TARGET;
      const isNewPosTarget = newMap[boxNewY][boxNewX] === TARGET;
      
      newMap[boxNewY][boxNewX] = isNewPosTarget ? BOX_ON_TARGET : BOX;
      newMap[newY][newX] = wasBoxOnTarget ? TARGET : EMPTY;
    }
  }
  
  if (canMove && !isDeadlock(newMap)) {
    states.push({
      map: newMap,
      player: { x: newX, y: newY }
    });
  }
}

return states;
```

};

const queue = [{ map: initialMap, player: playerStart }];
const visited = new Set([stringify(initialMap, playerStart)]);
let iterations = 0;
const maxIterations = 10000;

while (queue.length > 0 && iterations < maxIterations) {
iterations++;
const current = queue.shift();

```
if (isWinState(current.map)) {
  return { solvable: true, iterations };
}

const nextStates = getNextStates(current.map, current.player);

for (const state of nextStates) {
  const stateStr = stringify(state.map, state.player);
  if (!visited.has(stateStr)) {
    visited.add(stateStr);
    queue.push(state);
  }
}
```

}

return { solvable: false, iterations };
};

// Generate a solvable puzzle
const generatePuzzle = (level) => {
const params = getDifficultyParams(level);
let attempts = 0;
const maxAttempts = 100;

while (attempts < maxAttempts) {
attempts++;

```
// Create base map with walls around perimeter
const map = Array(params.height).fill().map(() => Array(params.width).fill(EMPTY));

// Add perimeter walls
for (let x = 0; x < params.width; x++) {
  map[0][x] = WALL;
  map[params.height - 1][x] = WALL;
}
for (let y = 0; y < params.height; y++) {
  map[y][0] = WALL;
  map[y][params.width - 1] = WALL;
}

// Add internal walls based on complexity
const numInternalWalls = Math.floor(params.complexity * 3);
for (let i = 0; i < numInternalWalls; i++) {
  const x = Math.floor(Math.random() * (params.width - 2)) + 1;
  const y = Math.floor(Math.random() * (params.height - 2)) + 1;
  
  if (Math.random() < params.narrowPassageProbability) {
    // Create narrow passages
    if (Math.random() < 0.5) {
      // Horizontal wall with gap
      const gapX = x + Math.floor(Math.random() * 3) - 1;
      for (let wx = x; wx < Math.min(x + 3, params.width - 1); wx++) {
        if (wx !== gapX && map[y][wx] === EMPTY) {
          map[y][wx] = WALL;
        }
      }
    } else {
      // Vertical wall with gap
      const gapY = y + Math.floor(Math.random() * 3) - 1;
      for (let wy = y; wy < Math.min(y + 3, params.height - 1); wy++) {
        if (wy !== gapY && map[wy][x] === EMPTY) {
          map[wy][x] = WALL;
        }
      }
    }
  } else if (Math.random() < params.deadEndProbability) {
    // Create L-shaped obstacles
    map[y][x] = WALL;
    if (x + 1 < params.width - 1) map[y][x + 1] = WALL;
    if (y + 1 < params.height - 1) map[y + 1][x] = WALL;
  } else {
    map[y][x] = WALL;
  }
}

// Find all empty spaces
const emptySpaces = [];
for (let y = 1; y < params.height - 1; y++) {
  for (let x = 1; x < params.width - 1; x++) {
    if (map[y][x] === EMPTY) {
      emptySpaces.push({ x, y });
    }
  }
}

if (emptySpaces.length < params.numBoxes + 1) continue;

// Shuffle empty spaces
for (let i = emptySpaces.length - 1; i > 0; i--) {
  const j = Math.floor(Math.random() * (i + 1));
  [emptySpaces[i], emptySpaces[j]] = [emptySpaces[j], emptySpaces[i]];
}

// Place player
const playerPos = emptySpaces.pop();

// Place boxes and targets
const boxPositions = [];
const targetPositions = [];

for (let i = 0; i < params.numBoxes; i++) {
  if (emptySpaces.length < 2) break;
  
  // Try to place box and target with some distance between them
  let boxPos, targetPos;
  let placementAttempts = 0;
  
  do {
    placementAttempts++;
    boxPos = emptySpaces[Math.floor(Math.random() * emptySpaces.length)];
    targetPos = emptySpaces[Math.floor(Math.random() * emptySpaces.length)];
  } while (boxPos === targetPos && placementAttempts < 50);
  
  if (placementAttempts >= 50) continue;
  
  boxPositions.push(boxPos);
  targetPositions.push(targetPos);
  
  // Remove from available spaces
  emptySpaces.splice(emptySpaces.indexOf(boxPos), 1);
  emptySpaces.splice(emptySpaces.indexOf(targetPos), 1);
  
  map[boxPos.y][boxPos.x] = BOX;
  map[targetPos.y][targetPos.x] = TARGET;
}

// Verify the puzzle is solvable
const solution = solvePuzzle(map, playerPos);

if (solution.solvable && solution.iterations > Math.max(10, level * 2)) {
  // Generate a name for this level
  const names = [
    "Shell Game", "Turtle Trap", "Slow Motion", "Green Dreams", "Pond Puzzle",
    "Lettuce Logic", "Shell Shock", "Turtle Power", "Flipper Challenge", "Aquatic Maze",
    "Reptile Riddle", "Shell Shuffle", "Turtle Tactics", "Pond Problem", "Green Geometry",
    "Carapace Conundrum", "Turtle Trials", "Shell Strategy", "Pond Perfection", "Turtle Triumph"
  ];
  
  const complexityNames = [
    "Simple", "Easy", "Moderate", "Tricky", "Challenging", "Hard", "Expert", "Master", "Legendary", "Impossible"
  ];
  
  const difficultyLevel = Math.floor(level / 5);
  const complexityName = complexityNames[Math.min(difficultyLevel, complexityNames.length - 1)];
  const baseName = names[level % names.length];
  
  return {
    name: `${baseName} (${complexityName})`,
    map: map,
    playerStart: playerPos,
    difficulty: level,
    solutionLength: solution.iterations,
    boxes: params.numBoxes
  };
}
```

}

// Fallback to a simple puzzle if generation fails
return {
name: `Fallback Level ${level + 1}`,
map: [
[1,1,1,1,1,1],
[1,0,0,0,0,1],
[1,0,2,3,0,1],
[1,0,0,0,0,1],
[1,1,1,1,1,1]
],
playerStart: { x: 1, y: 1 },
difficulty: level,
solutionLength: 5,
boxes: 1
};
};

const SolikobanTurtleFever = () => {
const [currentLevel, setCurrentLevel] = useState(0);
const [gameMap, setGameMap] = useState([]);
const [playerPos, setPlayerPos] = useState({ x: 0, y: 0 });
const [moves, setMoves] = useState(0);
const [isCompleted, setIsCompleted] = useState(false);
const [history, setHistory] = useState([]);
const [generatedLevels, setGeneratedLevels] = useState([]);
const [isGenerating, setIsGenerating] = useState(false);
const [levelStats, setLevelStats] = useState(null);

// Generate level when needed
const generateLevel = useCallback(async (levelNum) => {
setIsGenerating(true);

```
// Use setTimeout to allow UI to update
setTimeout(() => {
  const newLevel = generatePuzzle(levelNum);
  
  setGeneratedLevels(prev => {
    const updated = [...prev];
    updated[levelNum] = newLevel;
    return updated;
  });
  
  setLevelStats(newLevel);
  setIsGenerating(false);
}, 50);
```

}, []);

// Initialize game
const initGame = useCallback(async () => {
if (!generatedLevels[currentLevel]) {
await generateLevel(currentLevel);
return;
}

```
const level = generatedLevels[currentLevel];
const map = level.map.map(row => [...row]);

setGameMap(map);
setPlayerPos(level.playerStart);
setMoves(0);
setIsCompleted(false);
setHistory([]);
setLevelStats(level);
```

}, [currentLevel, generatedLevels, generateLevel]);

useEffect(() => {
initGame();
}, [initGame]);

// Generate next level when completing current one
useEffect(() => {
if (isCompleted && !generatedLevels[currentLevel + 1]) {
generateLevel(currentLevel + 1);
}
}, [isCompleted, currentLevel, generatedLevels, generateLevel]);

// Check if level is completed
const checkCompletion = useCallback((map) => {
for (let y = 0; y < map.length; y++) {
for (let x = 0; x < map[y].length; x++) {
if (map[y][x] === TARGET) {
return false;
}
}
}
return true;
}, []);

// Move player
const movePlayer = useCallback((dx, dy) => {
if (isCompleted) return;

```
const newX = playerPos.x + dx;
const newY = playerPos.y + dy;

// Check bounds
if (newY < 0 || newY >= gameMap.length || newX < 0 || newX >= gameMap[0].length) {
  return;
}

const targetTile = gameMap[newY][newX];

// Can't move into walls
if (targetTile === WALL) {
  return;
}

// Save state for undo
const currentState = {
  map: gameMap.map(row => [...row]),
  playerPos: { ...playerPos },
  moves
};

let newMap = gameMap.map(row => [...row]);
let canMove = true;

// Check if pushing a box
if (targetTile === BOX || targetTile === BOX_ON_TARGET) {
  const boxNewX = newX + dx;
  const boxNewY = newY + dy;

  // Check if box can be pushed
  if (boxNewY < 0 || boxNewY >= newMap.length || 
      boxNewX < 0 || boxNewX >= newMap[0].length ||
      newMap[boxNewY][boxNewX] === WALL ||
      newMap[boxNewY][boxNewX] === BOX ||
      newMap[boxNewY][boxNewX] === BOX_ON_TARGET) {
    canMove = false;
  } else {
    // Move the box
    const wasBoxOnTarget = targetTile === BOX_ON_TARGET;
    const isNewPosTarget = newMap[boxNewY][boxNewX] === TARGET;
    
    // Update box position
    newMap[boxNewY][boxNewX] = isNewPosTarget ? BOX_ON_TARGET : BOX;
    
    // Update current box position
    newMap[newY][newX] = wasBoxOnTarget ? TARGET : EMPTY;
  }
}

if (canMove) {
  setHistory(prev => [...prev, currentState]);
  setGameMap(newMap);
  setPlayerPos({ x: newX, y: newY });
  setMoves(prev => prev + 1);

  // Check completion
  if (checkCompletion(newMap)) {
    setIsCompleted(true);
  }
}
```

}, [playerPos, gameMap, moves, isCompleted, checkCompletion]);

// Undo last move
const undoMove = () => {
if (history.length === 0) return;

```
const lastState = history[history.length - 1];
setGameMap(lastState.map);
setPlayerPos(lastState.playerPos);
setMoves(lastState.moves);
setHistory(prev => prev.slice(0, -1));
setIsCompleted(false);
```

};

// Reset level
const resetLevel = () => {
initGame();
};

// Next level
const nextLevel = () => {
setCurrentLevel(prev => prev + 1);
};

// Previous level
const prevLevel = () => {
if (currentLevel > 0) {
setCurrentLevel(prev => prev - 1);
}
};

// Generate new level (replace current)
const regenerateLevel = () => {
generateLevel(currentLevel);
};

// Handle keyboard input
useEffect(() => {
const handleKeyPress = (e) => {
switch (e.key) {
case ‘ArrowUp’:
case ‘w’:
case ‘W’:
e.preventDefault();
movePlayer(0, -1);
break;
case ‘ArrowDown’:
case ‘s’:
case ‘S’:
e.preventDefault();
movePlayer(0, 1);
break;
case ‘ArrowLeft’:
case ‘a’:
case ‘A’:
e.preventDefault();
movePlayer(-1, 0);
break;
case ‘ArrowRight’:
case ‘d’:
case ‘D’:
e.preventDefault();
movePlayer(1, 0);
break;
case ‘z’:
case ‘Z’:
if (e.ctrlKey) {
e.preventDefault();
undoMove();
}
break;
case ‘r’:
case ‘R’:
e.preventDefault();
resetLevel();
break;
case ‘n’:
case ‘N’:
e.preventDefault();
regenerateLevel();
break;
}
};

```
window.addEventListener('keydown', handleKeyPress);
return () => window.removeEventListener('keydown', handleKeyPress);
```

}, [movePlayer]);

// Render tile
const renderTile = (tileType, x, y) => {
const isPlayerHere = playerPos.x === x && playerPos.y === y;

```
let content = '';
let bgColor = '';

switch (tileType) {
  case WALL:
    bgColor = 'bg-stone-800';
    content = '🧱';
    break;
  case BOX:
    bgColor = 'bg-yellow-100';
    content = '📦';
    break;
  case TARGET:
    bgColor = 'bg-green-200';
    content = '🎯';
    break;
  case BOX_ON_TARGET:
    bgColor = 'bg-green-400';
    content = '✅';
    break;
  default:
    bgColor = 'bg-blue-50';
    break;
}

// Show target underneath if player is on target
if (isPlayerHere && tileType === TARGET) {
  bgColor = 'bg-green-200';
}

return (
  <div
    key={`${x}-${y}`}
    className={`w-10 h-10 border border-gray-300 flex items-center justify-center text-lg ${bgColor}`}
  >
    {isPlayerHere ? '🐢' : content}
  </div>
);
```

};

if (isGenerating) {
return (
<div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-green-100 to-blue-100">
<div className="text-center">
<h1 className="text-4xl font-bold text-green-800 mb-4">🐢 Solikoban: Turtle Fever</h1>
<div className="text-xl text-green-700 mb-4">
🧠 Generating Level {currentLevel + 1}…
</div>
<div className="text-gray-600">
Creating a perfectly solvable puzzle just for you!
</div>
<div className="mt-4">
<div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto"></div>
</div>
</div>
</div>
);
}

return (
<div className="flex flex-col items-center p-6 bg-gradient-to-b from-green-100 to-blue-100 min-h-screen">
<h1 className="text-4xl font-bold text-green-800 mb-2">🐢 Solikoban: Turtle Fever</h1>

```
  <div className="mb-4 text-center">
    <h2 className="text-xl font-semibold text-green-700">
      Level {currentLevel + 1}: {levelStats?.name || 'Loading...'}
    </h2>
    <div className="text-sm text-gray-600 mt-1">
      {levelStats && (
        <>
          Boxes: {levelStats.boxes} | Difficulty: {levelStats.difficulty} | 
          Min Steps: ~{Math.floor(levelStats.solutionLength / 3)}
        </>
      )}
    </div>
    <p className="text-gray-600">Moves: {moves}</p>
  </div>

  {isCompleted && (
    <div className="mb-4 p-4 bg-green-200 border-2 border-green-400 rounded-lg">
      <p className="text-green-800 font-bold text-center">
        🎉 Level {currentLevel + 1} Complete! 🎉
      </p>
      <p className="text-green-700 text-center">
        Solved in {moves} moves! Next level is being prepared...
      </p>
    </div>
  )}

  <div className="mb-6 border-4 border-green-600 bg-white p-2 rounded-lg shadow-lg">
    <div className="grid gap-0" style={{gridTemplateColumns: `repeat(${gameMap[0]?.length || 8}, 1fr)`}}>
      {gameMap.map((row, y) =>
        row.map((tile, x) => renderTile(tile, x, y))
      )}
    </div>
  </div>

  <div className="flex flex-wrap gap-2 mb-4">
    <button
      onClick={() => movePlayer(0, -1)}
      className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 font-semibold"
    >
      ⬆️ Up
    </button>
    <button
      onClick={() => movePlayer(-1, 0)}
      className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 font-semibold"
    >
      ⬅️ Left
    </button>
    <button
      onClick={() => movePlayer(0, 1)}
      className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 font-semibold"
    >
      ⬇️ Down
    </button>
    <button
      onClick={() => movePlayer(1, 0)}
      className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 font-semibold"
    >
      ➡️ Right
    </button>
  </div>

  <div className="flex flex-wrap gap-2 mb-4">
    <button
      onClick={undoMove}
      disabled={history.length === 0}
      className="px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-semibold"
    >
      ↩️ Undo
    </button>
    <button
      onClick={resetLevel}
      className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 font-semibold"
    >
      🔄 Reset
    </button>
    <button
      onClick={regenerateLevel}
      className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 font-semibold"
    >
      🎲 New Puzzle
    </button>
  </div>

  <div className="flex gap-2 mb-4">
    <button
      onClick={prevLevel}
      disabled={currentLevel === 0}
      className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-semibold"
    >
      ⬅️ Previous
    </button>
    <button
      onClick={nextLevel}
      disabled={!isCompleted && currentLevel > 0}
      className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-semibold"
    >
      Next ➡️
    </button>
  </div>

  <div className="mt-6 text-center text-gray-600 max-w-md">
    <p className="font-semibold">🧠 Smart Generation System:</p>
    <p className="text-sm">Every puzzle is algorithmically generated and verified to be solvable!</p>
    <p className="text-sm">Difficulty scales automatically with each level.</p>
    <p className="text-sm mt-2">Press N for a new puzzle, R to reset, Ctrl+Z to undo</p>
    <p className="text-sm">Use WASD or arrow keys to move your turtle 🐢</p>
  </div>
</div>
```

);
};

export default SolikobanTurtleFever;