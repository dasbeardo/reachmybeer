<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>TOMY Waterful Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

```
    body {
        margin: 0;
        padding: 10px;
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: Arial, sans-serif;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
    }
    
    .game-container {
        background: linear-gradient(145deg, #333, #222);
        padding: 15px;
        border-radius: 25px;
        box-shadow: 
            0 15px 35px rgba(0,0,0,0.7),
            inset 0 2px 5px rgba(255,255,255,0.1);
        border: 3px solid #555;
        width: 100%;
        max-width: 380px;
        height: 100vh;
        max-height: 650px;
        display: flex;
        flex-direction: column;
        position: relative;
    }
    
    .game-title {
        text-align: center;
        color: #fff;
        margin-bottom: 8px;
        font-size: clamp(16px, 4vw, 20px);
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        background: linear-gradient(45deg, #00aaff, #ff6b6b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .instructions {
        text-align: center;
        color: #ffff00;
        margin-bottom: 10px;
        font-size: clamp(11px, 2.8vw, 14px);
        font-weight: bold;
        line-height: 1.3;
        background: rgba(0,0,0,0.3);
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,0,0.3);
    }
    
    .score {
        text-align: center;
        color: #00ff88;
        margin-bottom: 8px;
        font-size: clamp(12px, 3vw, 16px);
        font-weight: bold;
    }
    
    #game {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 15px;
        overflow: hidden;
        background: linear-gradient(180deg, #87ceeb 0%, #4682b4 100%);
        box-shadow: inset 0 4px 15px rgba(0,0,0,0.3);
    }
    
    .pressure-button {
        background: linear-gradient(45deg, #ff4444, #cc0000);
        border: none;
        color: white;
        padding: 25px;
        border-radius: 50%;
        font-size: clamp(16px, 4vw, 20px);
        font-weight: bold;
        cursor: pointer;
        transition: all 0.1s;
        box-shadow: 
            0 6px 20px rgba(255,68,68,0.4),
            inset 0 2px 5px rgba(255,255,255,0.2);
        margin-top: 15px;
        width: 80px;
        height: 80px;
        touch-action: manipulation;
        position: relative;
        align-self: center;
    }
    
    .pressure-button:active,
    .pressure-button.active {
        transform: translateY(3px) scale(0.95);
        box-shadow: 
            0 3px 10px rgba(255,68,68,0.8),
            inset 0 -2px 5px rgba(0,0,0,0.3);
        background: linear-gradient(45deg, #cc0000, #990000);
    }
    
    .tilt-indicator {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        border: 2px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        background: rgba(0,0,0,0.2);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .tilt-dot {
        width: 8px;
        height: 8px;
        background: #00ff88;
        border-radius: 50%;
        transition: transform 0.1s;
        box-shadow: 0 0 10px #00ff88;
    }
    
    canvas {
        max-width: 100%;
        max-height: 100%;
        border-radius: 10px;
    }

    .gyro-status {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #fff;
        font-size: 12px;
        background: rgba(0,0,0,0.5);
        padding: 5px 8px;
        border-radius: 5px;
        border: 1px solid rgba(255,255,255,0.2);
    }

    @media (max-height: 600px) {
        .game-container {
            padding: 10px;
            max-height: 500px;
        }
        .pressure-button {
            width: 70px;
            height: 70px;
            padding: 20px;
        }
    }
</style>
```

</head>
<body>
    <div class="game-container">
        <div class="game-title">ðŸŒŠ TOMY WATERFUL ðŸŒŠ</div>
        <div class="instructions">
            TILT your phone to guide rings!<br>
            Tap button for water pressure!
        </div>
        <div class="score">Score: <span id="score">0</span> / 4</div>

```
    <div class="gyro-status" id="gyroStatus">ðŸ”„ Initializing...</div>
    
    <div class="tilt-indicator">
        <div class="tilt-dot" id="tiltDot"></div>
    </div>
    
    <div id="game"></div>
    
    <button class="pressure-button" id="pressureButton">ðŸ’¨<br>PUSH</button>
</div>

<script>
    class WaterfulGame extends Phaser.Scene {
        constructor() {
            super({ key: 'WaterfulGame' });
            this.score = 0;
            this.rings = [];
            this.posts = [];
            this.tiltX = 0;
            this.tiltY = 0;
            this.waterPressureActive = false;
            this.gameWidth = 320;
            this.gameHeight = 480;
            this.gyroEnabled = false;
        }

        preload() {
            // Create textures
            this.add.graphics()
                .fillStyle(0xff6b6b)
                .fillCircle(15, 15, 15)
                .lineStyle(3, 0xffffff, 0.8)
                .strokeCircle(15, 15, 15)
                .generateTexture('ring', 30, 30);

            this.add.graphics()
                .fillStyle(0x4ecdc4)
                .fillRect(0, 0, 8, 50)
                .lineStyle(2, 0x339999)
                .strokeRect(0, 0, 8, 50)
                .generateTexture('post', 8, 50);

            this.add.graphics()
                .fillStyle(0x45b7d1)
                .fillCircle(2, 2, 2)
                .generateTexture('bubble', 4, 4);

            this.add.graphics()
                .fillStyle(0x8b4513)
                .fillRect(0, 0, 320, 20)
                .generateTexture('ground', 320, 20);

            this.add.graphics()
                .fillStyle(0x654321)
                .fillRect(0, 0, 20, 480)
                .generateTexture('wall', 20, 480);
        }

        create() {
            // Physics setup with dynamic gravity
            this.physics.world.setBounds(0, 0, this.gameWidth, this.gameHeight);
            this.physics.world.gravity.y = 400;

            // Create environment
            this.createEnvironment();
            this.createPosts();
            this.createRings();
            this.createWaterEffects();
            this.setupControls();
            this.setupCollisions();

            // Initialize gyroscope
            this.initializeGyroscope();

            // Water resistance simulation
            this.time.addEvent({
                delay: 50,
                callback: this.applyWaterResistance,
                callbackScope: this,
                loop: true
            });
        }

        createEnvironment() {
            // Ground
            const ground = this.add.image(this.gameWidth/2, this.gameHeight - 10, 'ground');
            this.physics.add.existing(ground, true);

            // Walls
            const leftWall = this.add.image(10, this.gameHeight/2, 'wall');
            const rightWall = this.add.image(this.gameWidth - 10, this.gameHeight/2, 'wall');
            this.physics.add.existing(leftWall, true);
            this.physics.add.existing(rightWall, true);

            // Water surface effect
            this.waterSurface = this.add.graphics();
            this.updateWaterSurface();
        }

        createPosts() {
            const postPositions = [
                { x: 80, y: this.gameHeight - 35 },
                { x: 160, y: this.gameHeight - 35 },
                { x: 240, y: this.gameHeight - 35 }
            ];

            postPositions.forEach(pos => {
                const post = this.add.image(pos.x, pos.y, 'post');
                this.physics.add.existing(post, true);
                this.posts.push(post);
            });
        }

        createRings() {
            const startPositions = [
                { x: 60, y: 100 },
                { x: 140, y: 80 },
                { x: 220, y: 120 },
                { x: 280, y: 90 }
            ];

            startPositions.forEach((pos, i) => {
                const ring = this.physics.add.sprite(pos.x, pos.y, 'ring');
                ring.setBounce(0.3);
                ring.setCollideWorldBounds(true);
                ring.setDrag(80); // Water resistance
                ring.body.setCircle(15);
                ring.setData('id', i);
                this.rings.push(ring);
            });
        }

        createWaterEffects() {
            // Water pressure particles
            this.waterPressure = this.add.particles(this.gameWidth/2, this.gameHeight - 60, 'bubble', {
                speed: { min: 100, max: 300 },
                angle: { min: 260, max: 280 },
                scale: { start: 0.5, end: 0 },
                lifespan: 800,
                frequency: 30,
                emitting: false,
                gravityY: -200
            });

            // Floating bubbles for atmosphere
            this.ambientBubbles = this.add.particles(0, this.gameHeight, 'bubble', {
                speed: { min: 20, max: 60 },
                angle: { min: 270, max: 270 },
                scale: { start: 0.2, end: 0 },
                lifespan: 3000,
                frequency: 500,
                x: { min: 0, max: this.gameWidth },
                gravityY: -50,
                alpha: { start: 0.6, end: 0 }
            });
        }

        setupControls() {
            const pressureButton = document.getElementById('pressureButton');

            // Enhanced button controls
            const activatePressure = () => {
                this.waterPressureActive = true;
                this.waterPressure.start();
                pressureButton.classList.add('active');
                this.applyWaterPressure();
            };

            const deactivatePressure = () => {
                this.waterPressureActive = false;
                this.waterPressure.stop();
                pressureButton.classList.remove('active');
            };

            // Touch events
            pressureButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                activatePressure();
            }, { passive: false });

            pressureButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                deactivatePressure();
            }, { passive: false });

            // Mouse events for desktop
            pressureButton.addEventListener('mousedown', activatePressure);
            pressureButton.addEventListener('mouseup', deactivatePressure);
            pressureButton.addEventListener('mouseleave', deactivatePressure);

            // Keyboard for testing
            this.input.keyboard.on('keydown-SPACE', activatePressure);
            this.input.keyboard.on('keyup-SPACE', deactivatePressure);
        }

        initializeGyroscope() {
            const statusEl = document.getElementById('gyroStatus');
            
            if ('DeviceOrientationEvent' in window) {
                // Request permission on iOS
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                this.setupOrientationListener();
                                this.gyroEnabled = true;
                                statusEl.textContent = 'ðŸ“± Gyro Active';
                            } else {
                                statusEl.textContent = 'âŒ Gyro Denied';
                                this.setupFallbackControls();
                            }
                        })
                        .catch(() => {
                            statusEl.textContent = 'âŒ Gyro Error';
                            this.setupFallbackControls();
                        });
                } else {
                    // Android/other devices
                    this.setupOrientationListener();
                    this.gyroEnabled = true;
                    statusEl.textContent = 'ðŸ“± Gyro Active';
                }
            } else {
                statusEl.textContent = 'âŒ No Gyro';
                this.setupFallbackControls();
            }
        }

        setupOrientationListener() {
            window.addEventListener('deviceorientation', (event) => {
                // Convert device orientation to tilt values
                // Beta: front-back tilt (-180 to 180)
                // Gamma: left-right tilt (-90 to 90)
                
                let beta = event.beta || 0;  // X-axis
                let gamma = event.gamma || 0; // Y-axis

                // Normalize and limit the values
                this.tiltX = Math.max(-1, Math.min(1, gamma / 30)); // Left-right
                this.tiltY = Math.max(-1, Math.min(1, (beta - 45) / 30)); // Forward-back (adjust for typical holding angle)

                // Update physics gravity based on tilt
                this.physics.world.gravity.x = this.tiltX * 300;
                this.physics.world.gravity.y = 400 + (this.tiltY * 200);

                // Update tilt indicator
                this.updateTiltIndicator();
                this.updateWaterSurface();
            });
        }

        setupFallbackControls() {
            // Touch controls for devices without gyro
            let isDragging = false;
            let lastTouch = { x: 0, y: 0 };

            this.input.on('pointerdown', (pointer) => {
                isDragging = true;
                lastTouch = { x: pointer.x, y: pointer.y };
            });

            this.input.on('pointermove', (pointer) => {
                if (isDragging) {
                    const deltaX = (pointer.x - lastTouch.x) / 100;
                    const deltaY = (pointer.y - lastTouch.y) / 100;
                    
                    this.tiltX = Math.max(-1, Math.min(1, this.tiltX + deltaX));
                    this.tiltY = Math.max(-1, Math.min(1, this.tiltY + deltaY));

                    this.physics.world.gravity.x = this.tiltX * 300;
                    this.physics.world.gravity.y = 400 + (this.tiltY * 200);

                    this.updateTiltIndicator();
                    this.updateWaterSurface();
                    
                    lastTouch = { x: pointer.x, y: pointer.y };
                }
            });

            this.input.on('pointerup', () => {
                isDragging = false;
            });
        }

        updateTiltIndicator() {
            const dot = document.getElementById('tiltDot');
            if (dot) {
                const translateX = this.tiltX * 20;
                const translateY = this.tiltY * 20;
                dot.style.transform = `translate(${translateX}px, ${translateY}px)`;
            }
        }

        updateWaterSurface() {
            this.waterSurface.clear();
            this.waterSurface.lineStyle(3, 0x87ceeb, 0.6);
            
            // Create wavy water surface that responds to tilt
            const surfaceY = this.gameHeight - 80;
            const waveAmplitude = 5 + Math.abs(this.tiltX) * 10;
            const waveOffset = this.tiltX * 20;
            
            this.waterSurface.beginPath();
            for (let x = 0; x <= this.gameWidth; x += 10) {
                const wave = Math.sin((x + waveOffset) * 0.02) * waveAmplitude;
                const y = surfaceY + wave + (this.tiltX * (x - this.gameWidth/2) * 0.1);
                
                if (x === 0) {
                    this.waterSurface.moveTo(x, y);
                } else {
                    this.waterSurface.lineTo(x, y);
                }
            }
            this.waterSurface.strokePath();
        }

        setupCollisions() {
            // Ring collisions
            this.rings.forEach(ring => {
                this.physics.add.collider(ring, this.physics.world.bounds);
            });

            // Ring to ring collisions
            for (let i = 0; i < this.rings.length; i++) {
                for (let j = i + 1; j < this.rings.length; j++) {
                    this.physics.add.collider(this.rings[i], this.rings[j]);
                }
            }
        }

        applyWaterPressure() {
            if (!this.waterPressureActive) return;

            // Apply upward force to rings near the pressure point
            const pressureX = this.gameWidth / 2;
            const pressureY = this.gameHeight - 60;
            const range = 80;

            this.rings.forEach(ring => {
                const distance = Phaser.Math.Distance.Between(pressureX, pressureY, ring.x, ring.y);
                
                if (distance < range) {
                    const force = (range - distance) / range * 400;
                    const angle = Phaser.Math.Angle.Between(pressureX, pressureY, ring.x, ring.y);
                    
                    ring.body.velocity.x += Math.cos(angle) * force * 0.5;
                    ring.body.velocity.y += Math.sin(angle) * force;
                }
            });
        }

        applyWaterResistance() {
            // Simulate water resistance
            this.rings.forEach(ring => {
                ring.body.velocity.x *= 0.98;
                ring.body.velocity.y *= 0.99;
            });
        }

        update() {
            if (this.waterPressureActive) {
                this.applyWaterPressure();
            }
            
            this.checkScoring();
        }

        checkScoring() {
            let ringsOnPosts = 0;
            
            this.rings.forEach(ring => {
                let isOnPost = false;
                this.posts.forEach(post => {
                    const distance = Phaser.Math.Distance.Between(ring.x, ring.y, post.x, post.y - 25);
                    if (distance < 25) {
                        isOnPost = true;
                    }
                });
                
                if (isOnPost) {
                    ringsOnPosts++;
                    ring.setTint(0x00ff88);
                } else {
                    ring.clearTint();
                }
            });

            if (ringsOnPosts !== this.score) {
                this.score = ringsOnPosts;
                document.getElementById('score').textContent = this.score;
                
                if (this.score === this.rings.length) {
                    this.celebrateWin();
                }
            }
        }

        celebrateWin() {
            this.add.text(this.gameWidth/2, this.gameHeight/2, 'PERFECT!\nAll rings scored!', {
                fontSize: '28px',
                fill: '#ffff00',
                align: 'center',
                stroke: '#000',
                strokeThickness: 3
            }).setOrigin(0.5);

            // Victory confetti
            this.add.particles(this.gameWidth/2, this.gameHeight/2, 'bubble', {
                speed: { min: 100, max: 300 },
                scale: { start: 1, end: 0 },
                blendMode: 'ADD',
                lifespan: 2000,
                quantity: 50
            });

            this.time.delayedCall(3000, () => {
                this.scene.restart();
            });
        }
    }

    // Game configuration
    const config = {
        type: Phaser.AUTO,
        width: 320,
        height: 480,
        parent: 'game',
        backgroundColor: '#4682b4',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 400 },
                debug: false
            }
        },
        scene: WaterfulGame,
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH
        }
    };

    // Start the game
    const game = new Phaser.Game(config);

    // Prevent page scrolling
    document.addEventListener('touchmove', (e) => {
        e.preventDefault();
    }, { passive: false });

    // Handle orientation changes
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            game.scale.refresh();
        }, 100);
    });
</script>
```

</body>
</html>