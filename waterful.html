<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>TOMY Waterful Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

```
    body {
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: Arial, sans-serif;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
    }
    
    .game-container {
        background: linear-gradient(145deg, #333, #222);
        padding: 15px;
        border-radius: 25px;
        box-shadow: 0 15px 35px rgba(0,0,0,0.7);
        border: 3px solid #555;
        width: 90vw;
        max-width: 400px;
        height: 80vh;
        max-height: 600px;
        display: flex;
        flex-direction: column;
    }
    
    .title {
        text-align: center;
        color: #fff;
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 10px;
    }
    
    .status {
        text-align: center;
        color: #ffff00;
        font-size: 12px;
        margin-bottom: 10px;
        min-height: 30px;
    }
    
    #gameCanvas {
        flex: 1;
        border: 3px solid #222;
        border-radius: 10px;
        background: linear-gradient(180deg, #87ceeb 0%, #4682b4 100%);
        max-width: 100%;
        max-height: 100%;
    }
    
    .controls {
        margin-top: 15px;
        text-align: center;
    }
    
    .water-button {
        background: linear-gradient(45deg, #ff4444, #cc0000);
        border: none;
        color: white;
        padding: 20px;
        border-radius: 50%;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 6px 20px rgba(255,68,68,0.4);
        width: 80px;
        height: 80px;
        touch-action: manipulation;
    }
    
    .water-button:active {
        transform: translateY(3px) scale(0.95);
        box-shadow: 0 3px 10px rgba(255,68,68,0.8);
    }
</style>
```

</head>
<body>
    <div class="game-container">
        <div class="title">ðŸŒŠ TOMY WATERFUL ðŸŒŠ</div>
        <div class="status" id="status">Requesting gyroscope access...</div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <button class="water-button" id="waterButton">ðŸ’¨<br>PUSH</button>
        </div>
    </div>

```
<script>
    class WaterfulGame {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.status = document.getElementById('status');
            
            // Set canvas size
            this.resizeCanvas();
            window.addEventListener('resize', () => this.resizeCanvas());
            
            // Game state
            this.tiltX = 0;
            this.tiltY = 0;
            this.waterPressure = false;
            this.rings = [];
            this.posts = [];
            this.waterParticles = [];
            
            // Physics constants
            this.gravity = 0.5;
            this.waterDensity = 0.02;
            this.buoyancy = 0.3;
            this.friction = 0.98;
            
            this.initGame();
            this.initGyroscope();
            this.initControls();
            this.gameLoop();
        }
        
        resizeCanvas() {
            const container = this.canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const maxWidth = rect.width - 30;
            const maxHeight = rect.height - 150;
            
            this.canvas.width = Math.min(300, maxWidth);
            this.canvas.height = Math.min(400, maxHeight);
            
            this.width = this.canvas.width;
            this.height = this.canvas.height;
        }
        
        initGame() {
            // Create posts
            this.posts = [
                { x: this.width * 0.25, y: this.height - 30, width: 6, height: 40 },
                { x: this.width * 0.5, y: this.height - 30, width: 6, height: 40 },
                { x: this.width * 0.75, y: this.height - 30, width: 6, height: 40 }
            ];
            
            // Create rings
            this.rings = [
                { 
                    x: this.width * 0.2, 
                    y: this.height * 0.3, 
                    vx: 0, 
                    vy: 0, 
                    radius: 12,
                    density: 0.8, // Floats
                    onPost: false,
                    id: 0
                },
                { 
                    x: this.width * 0.4, 
                    y: this.height * 0.4, 
                    vx: 0, 
                    vy: 0, 
                    radius: 12,
                    density: 0.8,
                    onPost: false,
                    id: 1
                },
                { 
                    x: this.width * 0.6, 
                    y: this.height * 0.2, 
                    vx: 0, 
                    vy: 0, 
                    radius: 12,
                    density: 0.8,
                    onPost: false,
                    id: 2
                },
                { 
                    x: this.width * 0.8, 
                    y: this.height * 0.35, 
                    vx: 0, 
                    vy: 0, 
                    radius: 12,
                    density: 0.8,
                    onPost: false,
                    id: 3
                }
            ];
        }
        
        initGyroscope() {
            if (typeof DeviceOrientationEvent !== 'undefined') {
                // Request permission for iOS 13+
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                this.startGyroscope();
                            } else {
                                this.status.textContent = 'Gyroscope permission denied. Tap screen to tilt.';
                                this.initTouchTilt();
                            }
                        })
                        .catch(() => {
                            this.status.textContent = 'Gyroscope error. Tap screen to tilt.';
                            this.initTouchTilt();
                        });
                } else {
                    // Android or older iOS
                    this.startGyroscope();
                }
            } else {
                this.status.textContent = 'No gyroscope. Tap screen to tilt.';
                this.initTouchTilt();
            }
        }
        
        startGyroscope() {
            window.addEventListener('deviceorientation', (event) => {
                // Convert device orientation to normalized tilt values
                const beta = event.beta || 0;   // Front-back tilt
                const gamma = event.gamma || 0; // Left-right tilt
                
                // Normalize to -1 to 1 range
                this.tiltX = Math.max(-1, Math.min(1, gamma / 45));
                this.tiltY = Math.max(-1, Math.min(1, (beta - 90) / 45));
                
                this.status.textContent = `Tilt: ${this.tiltX.toFixed(2)}, ${this.tiltY.toFixed(2)} | Score: ${this.getScore()}/4`;
            });
            
            this.status.textContent = 'Gyroscope active! Tilt phone to play.';
        }
        
        initTouchTilt() {
            let isDragging = false;
            let lastTouch = { x: 0, y: 0 };
            
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = true;
                const touch = e.touches[0];
                lastTouch = { x: touch.clientX, y: touch.clientY };
            });
            
            this.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isDragging) {
                    const touch = e.touches[0];
                    const deltaX = (touch.clientX - lastTouch.x) / 100;
                    const deltaY = (touch.clientY - lastTouch.y) / 100;
                    
                    this.tiltX = Math.max(-1, Math.min(1, this.tiltX + deltaX));
                    this.tiltY = Math.max(-1, Math.min(1, this.tiltY + deltaY));
                    
                    lastTouch = { x: touch.clientX, y: touch.clientY };
                }
            });
            
            this.canvas.addEventListener('touchend', () => {
                isDragging = false;
            });
        }
        
        initControls() {
            const button = document.getElementById('waterButton');
            
            const startPressure = () => {
                this.waterPressure = true;
                button.style.transform = 'translateY(3px) scale(0.95)';
            };
            
            const stopPressure = () => {
                this.waterPressure = false;
                button.style.transform = '';
            };
            
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startPressure();
            });
            
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopPressure();
            });
            
            button.addEventListener('mousedown', startPressure);
            button.addEventListener('mouseup', stopPressure);
            button.addEventListener('mouseleave', stopPressure);
        }
        
        updatePhysics() {
            // Update rings with real physics
            this.rings.forEach(ring => {
                // Apply gravity based on device tilt
                const gravityX = this.tiltX * this.gravity;
                const gravityY = this.gravity + (this.tiltY * this.gravity);
                
                // Water level (assume water fills bottom 80% of container)
                const waterLevel = this.height * 0.8;
                const isInWater = ring.y > waterLevel - ring.radius;
                
                if (isInWater) {
                    // Buoyancy force (upward)
                    const submergedRatio = Math.min(1, (ring.y - (waterLevel - ring.radius)) / (ring.radius * 2));
                    const buoyancyForce = this.buoyancy * submergedRatio;
                    
                    // Apply buoyancy (opposes gravity)
                    ring.vy -= buoyancyForce;
                    
                    // Water resistance
                    ring.vx *= 0.85;
                    ring.vy *= 0.9;
                    
                    // Density affects how much it floats
                    if (ring.density < 1.0) {
                        ring.vy -= (1.0 - ring.density) * 0.1;
                    }
                }
                
                // Apply gravity
                ring.vx += gravityX;
                ring.vy += gravityY;
                
                // Water pressure effect
                if (this.waterPressure && isInWater) {
                    const pressureX = this.width / 2;
                    const pressureY = this.height - 20;
                    const dx = ring.x - pressureX;
                    const dy = ring.y - pressureY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 80) {
                        const force = (80 - distance) / 80 * 0.8;
                        const angle = Math.atan2(dy, dx);
                        ring.vx += Math.cos(angle) * force;
                        ring.vy += Math.sin(angle) * force;
                        
                        // Create bubbles
                        if (Math.random() < 0.3) {
                            this.waterParticles.push({
                                x: pressureX + (Math.random() - 0.5) * 40,
                                y: pressureY + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 4,
                                vy: -Math.random() * 8,
                                life: 1.0,
                                radius: Math.random() * 3 + 1
                            });
                        }
                    }
                }
                
                // Update position
                ring.x += ring.vx;
                ring.y += ring.vy;
                
                // Boundary collisions with realistic bounce
                if (ring.x - ring.radius < 0) {
                    ring.x = ring.radius;
                    ring.vx *= -0.6;
                }
                if (ring.x + ring.radius > this.width) {
                    ring.x = this.width - ring.radius;
                    ring.vx *= -0.6;
                }
                if (ring.y - ring.radius < 0) {
                    ring.y = ring.radius;
                    ring.vy *= -0.4;
                }
                if (ring.y + ring.radius > this.height) {
                    ring.y = this.height - ring.radius;
                    ring.vy *= -0.4;
                    ring.vx *= 0.9; // Floor friction
                }
            });
            
            // Update water particles
            this.waterParticles = this.waterParticles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.2; // Gravity on bubbles
                particle.life -= 0.02;
                return particle.life > 0 && particle.y > 0;
            });
            
            // Ring-ring collisions
            for (let i = 0; i < this.rings.length; i++) {
                for (let j = i + 1; j < this.rings.length; j++) {
                    const ring1 = this.rings[i];
                    const ring2 = this.rings[j];
                    const dx = ring2.x - ring1.x;
                    const dy = ring2.y - ring1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = ring1.radius + ring2.radius;
                    
                    if (distance < minDistance) {
                        // Collision response
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        // Separate rings
                        const overlap = minDistance - distance;
                        ring1.x -= cos * overlap * 0.5;
                        ring1.y -= sin * overlap * 0.5;
                        ring2.x += cos * overlap * 0.5;
                        ring2.y += sin * overlap * 0.5;
                        
                        // Exchange velocities (simplified)
                        const v1 = ring1.vx * cos + ring1.vy * sin;
                        const v2 = ring2.vx * cos + ring2.vy * sin;
                        ring1.vx += (v2 - v1) * cos * 0.8;
                        ring1.vy += (v2 - v1) * sin * 0.8;
                        ring2.vx += (v1 - v2) * cos * 0.8;
                        ring2.vy += (v1 - v2) * sin * 0.8;
                    }
                }
            }
            
            // Check scoring
            this.rings.forEach(ring => {
                ring.onPost = false;
                this.posts.forEach(post => {
                    if (ring.x > post.x - post.width/2 - ring.radius &&
                        ring.x < post.x + post.width/2 + ring.radius &&
                        ring.y > post.y - post.height &&
                        ring.y < post.y + ring.radius) {
                        ring.onPost = true;
                    }
                });
            });
        }
        
        getScore() {
            return this.rings.filter(ring => ring.onPost).length;
        }
        
        render() {
            // Clear canvas
            this.ctx.fillStyle = '#4682b4';
            this.ctx.fillRect(0, 0, this.width, this.height);
            
            // Draw water
            const waterLevel = this.height * 0.8;
            this.ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
            this.ctx.fillRect(0, waterLevel, this.width, this.height - waterLevel);
            
            // Draw water surface with tilt effect
            this.ctx.strokeStyle = '#87ceeb';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            const tiltOffset = this.tiltX * 10;
            this.ctx.moveTo(0, waterLevel + tiltOffset);
            this.ctx.lineTo(this.width, waterLevel - tiltOffset);
            this.ctx.stroke();
            
            // Draw posts
            this.ctx.fillStyle = '#4ecdc4';
            this.posts.forEach(post => {
                this.ctx.fillRect(
                    post.x - post.width/2, 
                    post.y - post.height, 
                    post.width, 
                    post.height
                );
            });
            
            // Draw water particles
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            this.waterParticles.forEach(particle => {
                this.ctx.globalAlpha = particle.life;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                this.ctx.fill();
            });
            this.ctx.globalAlpha = 1;
            
            // Draw rings
            this.rings.forEach(ring => {
                this.ctx.fillStyle = ring.onPost ? '#00ff88' : '#ff6b6b';
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Inner circle
                this.ctx.fillStyle = ring.onPost ? '#004444' : '#880000';
                this.ctx.beginPath();
                this.ctx.arc(ring.x, ring.y, ring.radius * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
            });
        }
        
        gameLoop() {
            this.updatePhysics();
            this.render();
            
            // Update status
            if (this.status.textContent.includes('Tilt:')) {
                this.status.textContent = `Tilt: ${this.tiltX.toFixed(2)}, ${this.tiltY.toFixed(2)} | Score: ${this.getScore()}/4`;
            }
            
            requestAnimationFrame(() => this.gameLoop());
        }
    }
    
    // Start game when page loads
    window.addEventListener('load', () => {
        new WaterfulGame();
    });
    
    // Prevent page scrolling
    document.addEventListener('touchmove', (e) => {
        e.preventDefault();
    }, { passive: false });
</script>
```

</body>
</html>